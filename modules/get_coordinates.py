import math
from geographiclib.geodesic import Geodesic
import cv2
import numpy as np
from typing import Tuple

def degrees_to_d_m_s(degrees: float) -> Tuple[int, int, float]:
    """Converts decimal degrees to degrees, minutes and seconds.

    Args:
        degrees - floating value of geo postion in one var

    Returns:
        A tuple ``(d, m, s)`` where ``d`` and ``m`` are integers representing
        degrees and minutes and ``s`` is a float representing seconds.
    """
    d = int(degrees)
    minutes_decimal = (degrees - d) * 60
    m = int(minutes_decimal)
    s = (minutes_decimal - m) * 60
    return d, m, s

def d_m_s_to_degrees(d:int, m:int, s:float) -> float:
    """Converts degrees, minutes, and seconds to decimal degrees.

    Args:
        d - degrees
        m - minutes
        s - seconds

    Returns:
        degrees - floating value of geo postion in one var
    """
    degrees = d + (m / 60) + (s / 3600)
    return degrees

def pixels_to_meters(
    pixels: int,
    altitude: float,
    focal_length_px: float,
) -> float:
    """Convert a distance in pixels to meters using camera intrinsics.

    Args:
        pixels: Distance in image pixels.
        altitude: Altitude of the camera above the ground in meters.
        focal_length_px: Focal length in *pixels* (fx or fy from the camera matrix).

    Returns:
        Distance expressed in meters.
    """
    meters_per_pixel = altitude / focal_length_px
    return pixels * meters_per_pixel


def translate(
    x: float,
    y: float,
    altitude: float,
    camera_matrix: np.ndarray,
    dist_coeffs: np.ndarray,
    angle: float = 0.0,
) -> Tuple[float, float]:
    """Calculate the metric offset from the image centre using camera intrinsics.

    Args:
        x: X pixel coordinate of the detected object.
        y: Y pixel coordinate of the detected object.
        altitude: Altitude of the camera in meters.
        camera_matrix: 3x3 intrinsic camera matrix ``[[fx,0,cx],[0,fy,cy],[0,0,1]]``.
        dist_coeffs: Distortion coefficients for the lens.
        angle: Optional rotation of the image around the optical axis (radians).

    Returns:
        ``delta_x_meters`` and ``delta_y_meters`` describing the offset from the
        image centre in metres.
    """

    pts = np.array([[[x, y]]], dtype=np.float32)
    norm = cv2.undistortPoints(pts, camera_matrix, dist_coeffs)
    xn, yn = norm[0, 0]

    # Coordinates on the ground plane assuming the camera looks straight down.
    X = xn * altitude
    Y = yn * altitude

    # Apply optional rotation around the Z axis.
    Xr = X * math.cos(angle) - Y * math.sin(angle)
    Yr = X * math.sin(angle) + Y * math.cos(angle)

    delta_x_meters = Xr
    delta_y_meters = -Yr

    return delta_x_meters, delta_y_meters


def calculate_new_coordinates(
    lat: float,  # lateral position of drone
    lng: float,  # longitudinal position of drone
    delta_x_meters: float,  # meters distance from middle on x axis
    delta_y_meters: float,  # meters distance from middle on y axis
) -> Tuple[float, float]:  # tuple containing the object's latitude and longitude
    """
    Function uses geographiclib library to estimate geo position of
    detected object.

    Args:
        lat - lateral position of drone in geo notation (degrees)
        lng - longitudinal position of drone in geo notation (degrees)
        delta_x_meters - distance from the middle on x axis with meters
        delta_y_meters - distance from the middle on y axis with meters
    Returns:
        A tuple ``(new_lat, new_lng)`` with the latitude and longitude of the
        detected object in degrees.
    """
    geod = Geodesic.WGS84
    result_lat = geod.Direct(lat, lng, 0, delta_y_meters)
    new_lat = result_lat["lat2"]
    lat_rad = math.radians(lat)
    result_lon = geod.Direct(lat, lng, 90, delta_x_meters * math.cos(lat_rad))
    new_lng = result_lon["lon2"]
    return new_lat, new_lng


def unit_test_get_coordinates():
    """
    Unit test for pixels_to_meters, translate, and calculate_new_coordinates functions.
    Checks if the coordinate transformation pipeline works as expected.

    (Generated by AI because lack of test data)
    """
    # Example parameters
    x_pixel = 2736  # center of image width for 5472px
    y_pixel = 1824  # center of image height for 3648px
    altitude = 100.0  # meters
    lat = 50.0
    lng = 19.0
    angle = 0.0
    img_height = 3648.0
    img_width = 5472.0

    # Approximate camera intrinsics for the test
    fx = fy = 4955.0
    cx = img_width / 2.0
    cy = img_height / 2.0
    camera_matrix = np.array([[fx, 0, cx], [0, fy, cy], [0, 0, 1]], dtype=np.float32)
    dist_coeffs = np.zeros(5)

    # Test translate for center (should be close to 0,0)
    delta_x, delta_y = translate(
        x_pixel,
        y_pixel,
        altitude,
        camera_matrix,
        dist_coeffs,
        angle,
    )
    print(f"delta_x: {delta_x}, delta_y: {delta_y}")
    assert abs(delta_x) < 1e-6, "delta_x should be near zero for image center"
    assert abs(delta_y) < 1e-6, "delta_y should be near zero for image center"

    # Test calculate_new_coordinates (should return original lat/lng for center)
    new_lat, new_lng = calculate_new_coordinates(lat, lng, delta_x, delta_y)
    print(f"new_lat: {new_lat}, new_lng: {new_lng}")
    assert abs(new_lat - lat) < 1e-6, "Latitude should not change for image center"
    assert abs(new_lng - lng) < 1e-6, "Longitude should not change for image center"

    # Test for a point away from center
    x_pixel2 = 3000
    y_pixel2 = 2000

    delta_x2, delta_y2 = translate(
        x_pixel2,
        y_pixel2,
        altitude,
        camera_matrix,
        dist_coeffs,
        angle,
    )
    new_lat2, new_lng2 = calculate_new_coordinates(lat, lng, delta_x2, delta_y2)
    print(f"Offset lat/lng: {new_lat2}, {new_lng2}")

    print("All tests passed.")


if __name__ == "__main__":
    # Example usage of the utilities

    # Run the simple unit test when executed directly
    unit_test_get_coordinates()
